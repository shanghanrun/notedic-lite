<script>
  import { pb } from "$lib/pb.svelte";
  import { onMount, onDestroy } from "svelte";
  import { chatManager } from "$lib/chatManager.svelte";

  // --- ìƒíƒœ ê´€ë¦¬ ($state) ---
  let now = $state(Date.now());
  let currentUser = $state(pb.authStore.model);

  let heartbeatInterval;
  let timerInterval;


  let email = $state("");
  let password = $state("");
  let isLogged = $state(pb.authStore.isValid); // ë¡œê·¸ì¸ ì—¬ë¶€ ì²´í¬

  async function handleLogin() {
    try {
      // 1. ê¸°ì¡´ ì„¸ì…˜ ë¹„ìš°ê¸° (í•„ìˆ˜!)
      pb.authStore.clear();

      // 2. ì…ë ¥ë°›ì€ ì •ë³´ë¡œ ë¡œê·¸ì¸
      await pb.collection("users").authWithPassword(email, password);

      // 3. ì„±ê³µ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
      currentUser = pb.authStore.model;
      isLogged = true;

      // 4. ì±„íŒ… ë°ì´í„° ì´ˆê¸°í™”
      await chatManager.initChat();
      alert(`${currentUser.name || "ìœ ì €"}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`);
    } catch (err) {
      alert("ë¡œê·¸ì¸ ì‹¤íŒ¨: ì´ë©”ì¼ì´ë‚˜ ë¹„ë²ˆì„ í™•ì¸í•˜ì„¸ìš”!");
    }
  }

  function logout() {
    pb.authStore.clear();
    isLogged = false;
    location.reload(); // ê¹”ë”í•˜ê²Œ ìƒˆë¡œê³ ì¹¨
  }

  async function updateMyStatus() {
        if (!pb.authStore.model) return;
        const userId = pb.authStore.model.id;
        try {
            const existing = await pb.collection("online_status").getFirstListItem(`userId="${userId}"`).catch(() => null);
            if (existing) {
                await pb.collection("online_status").update(existing.id, { last_seen: new Date().toISOString() });
            } else {
                await pb.collection("online_status").create({ userId, last_seen: new Date().toISOString() });
            }
        } catch (err) { console.error("í•˜íŠ¸ë¹„íŠ¸ ì—ëŸ¬", err); }
  }

  async function init() {
        if (!pb.authStore.isValid) return;

        try {
            // 1. ì´ˆê¸° ë°ì´í„° ì„¸íŒ…
            chatManager.users = await pb.collection("users").getFullList();
            chatManager.rooms = await pb.collection("rooms").getFullList({ filter: "active = true" });
            
            // 2. í•˜íŠ¸ë¹„íŠ¸ ì‹œì‘
            updateMyStatus();
            heartbeatInterval = setInterval(updateMyStatus, 30000);

            // 3. ì‹¤ì‹œê°„ ì˜¨ë¼ì¸ ê°ì§€
            pb.collection("online_status").subscribe("*", ({ action, record }) => {
                chatManager.onlineMap = { ...chatManager.onlineMap, [record.userId]: record.last_seen };
            });

            // 4. ì‹¤ì‹œê°„ ë©”ì‹œì§€ ê°ì§€
            pb.collection("messages").subscribe("*", ({ action, record }) => {
                if (action === "create" && record.room === chatManager.activeRoomId) {
                    chatManager.messages = [...chatManager.messages, record];
                }
            }, { expand: "user" });

            // 5. ì‹¤ì‹œê°„ ë°© ëª©ë¡ ê°ì§€ (ëˆ„ê°€ ë°© ìƒˆë¡œ ë§Œë“¤ë©´ ë°”ë¡œ ëœ¨ê²Œ)
            pb.collection("rooms").subscribe("*", ({ action, record }) => {
                if (action === "create") chatManager.rooms = [...chatManager.rooms, record];
                if (action === "update") chatManager.rooms = chatManager.rooms.map(r => r.id === record.id ? record : r);
            });

        } catch (err) { console.error("ì´ˆê¸°í™” ì‹¤íŒ¨", err); }
  }

  // 2. ì´ˆê¸°í™” ë° ì‹¤ì‹œê°„ ë°ì´í„° ë°”ì¸ë”©
  async function initChat() {
    if (!pb.authStore.isValid) return;

    try {
      // (1) ê¸°ë³¸ ì •ë³´ ë¡œë“œ
      users = await pb.collection("users").getFullList();
      rooms = await pb
        .collection("rooms")
        .getFullList({ filter: "active = true" });
      if (rooms.length > 0 && !activeRoomId) activeRoomId = rooms[0].id;

      // (2) ì˜¨ë¼ì¸ ìƒíƒœ ì´ˆê¸° ë¡œë“œ (userId í•„ë“œ ê¸°ì¤€)
      const statuses = await pb.collection("online_status").getFullList();
      const tempObj = {};
      statuses.forEach((s) => {
        if (s.userId) tempObj[s.userId] = s.last_seen;
      });
      onlineMap = tempObj; // ê°ì²´ í†µì§¸ë¡œ ê°ˆì•„ë¼ìš°ê¸°

      // (3) í•˜íŠ¸ë¹„íŠ¸ ì‹œì‘ (30ì´ˆ ì£¼ê¸°)
      updateMyStatus();
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      heartbeatInterval = setInterval(updateMyStatus, 30000);

      // (4) [ì‹¤ì‹œê°„] ì˜¨ë¼ì¸ ìƒíƒœ ë³€í™” ê°ì§€
      pb.collection("online_status").subscribe("*", ({ action, record }) => {
        if (action === "create" || action === "update") {
          // ìƒˆë¡œìš´ ê°ì²´ë¥¼ í• ë‹¹í•˜ì—¬ ë°˜ì‘ì„±ì„ ê°•ì œí•¨
          onlineMap = { ...onlineMap, [record.userId]: record.last_seen };
        }
      });

      // (5) [ì‹¤ì‹œê°„] ë©”ì‹œì§€ ê°ì§€
      pb.collection("messages").subscribe(
        "*",
        ({ action, record }) => {
          if (action === "create" && record.room === activeRoomId) {
            if (!messages.find((m) => m.id === record.id)) {
              messages = [...messages, record];
            }
          }
        },
        { expand: "user" },
      );
    } catch (err) {
      console.error("âŒ ì´ˆê¸°í™” ì—ëŸ¬:", err);
    }
  }

  // 3. ë‚´ ì˜¨ë¼ì¸ ìƒíƒœ ì „ì†¡ (í•˜íŠ¸ë¹„íŠ¸)
  async function updateMyStatus() {
    const myId = pb.authStore.model?.id; // ì—¬ê¸°ì„œ ìë™ìœ¼ë¡œ '6gsm4ykrqgd2pdb'ê°€ ì¡í™ë‹ˆë‹¤.
    if (!myId) return;

    try {
      let existing = null;
      try {
        existing = await pb
          .collection("online_status")
          .getFirstListItem(`userId="${myId}"`);
      } catch (e) {}

      const data = {
        userId: myId,
        last_seen: new Date().toISOString(),
        is_online: true,
      };

      if (existing) {
        await pb.collection("online_status").update(existing.id, data);
      } else {
        await pb.collection("online_status").create(data);
      }
      console.log("âœ… í•˜íŠ¸ë¹„íŠ¸ ì „ì†¡ ì„±ê³µ (ID:", myId, ")");
    } catch (err) {
      console.error("âŒ í•˜íŠ¸ë¹„íŠ¸ ì‹¤íŒ¨:", err);
    }
  }

  // 4. â˜…í•µì‹¬â˜… ì˜¨ë¼ì¸ ì—¬ë¶€ íŒë‹¨ í•¨ìˆ˜
  function isOnline(userIdToCheck) {
    if (!userIdToCheck) return false;

    // 1. [ë³¸ì¸ í™•ì¸] ë¡œê·¸ì¸í•œ IDì™€ ëª©ë¡ì˜ IDê°€ ê°™ìœ¼ë©´ ë¬´ì¡°ê±´ ì¼¬
    if (userIdToCheck === pb.authStore.model?.id) {
      return true;
    }

    // 2. [íƒ€ì¸ í™•ì¸] ë‚˜ë¨¸ì§€ëŠ” ì§€ë„ì— ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸
    console.log("onlineMap ì¶œë ¥");
    console.table(onlineMap);
    const lastSeenStr = onlineMap[userIdToCheck];
    if (!lastSeenStr) return false;

    const lastSeenTime = new Date(lastSeenStr).getTime();
    return Date.now() - lastSeenTime < 90000;
  }

  onMount(async () => {
    // await loginAsChoco();
    // console.log("ì´ˆì½” ë¡œê·¸ì¸");
    // await loginAsTest();
    // console.log("í…ŒìŠ¤íŠ¸ ë¡œê·¸ì¸");
    // 10ì´ˆë§ˆë‹¤ 'now'ë¥¼ ê°±ì‹ í•˜ì—¬ í™”ë©´ì˜ ë¶ˆë¹› ìƒíƒœë¥¼ ìƒˆë¡œê³ ì¹¨í•¨
    timerInterval = setInterval(() => {
      now = Date.now();
    }, 10000);

    return () => {
      if (heartbeatInterval) clearInterval(heartbeatInterval);
      if (timerInterval) clearInterval(timerInterval);
      pb.collection("online_status").unsubscribe();
      pb.collection("messages").unsubscribe();
    };
  });

  // ë°© ë³€ê²½ ì‹œ ë©”ì‹œì§€ ë°ì´í„° ë¡œë“œ
  $effect(async () => {
    if (activeRoomId && pb.authStore.isValid) {
      const res = await pb.collection("messages").getList(1, 50, {
        filter: `room = "${activeRoomId}"`,
        expand: "user",
        sort: "created",
      });
      messages = res.items;
    }
  });

  async function sendMessage() {
    if (!newMessage.trim() || !activeRoomId) return;
    try {
      await pb.collection("messages").create({
        room: activeRoomId,
        user: pb.authStore.model.id,
        content: newMessage,
      });
      newMessage = "";
    } catch (err) {
      console.error("âŒ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨:", err);
    }
  }
</script>

<!-- {#if !currentUser}
  <div class="loading">ì„œë²„ ì—°ê²° ì¤‘...</div>
{:else} -->
  <div class="chat-layout">
    <aside class="user-list">
      {#if !isLogged}
        <div class="login-container">
          <h2>ğŸš€ í˜•ë‹˜ ë©”ì‹ ì € ë¡œê·¸ì¸</h2>
          <input type="email" bind:value={email} placeholder="ì´ë©”ì¼ ì…ë ¥" />
          <input
            type="password"
            bind:value={password}
            placeholder="ë¹„ë°€ë²ˆí˜¸ ì…ë ¥"
          />
          <button onclick={handleLogin}>ì ‘ì†í•˜ê¸°</button>
        </div>
      {:else}
        <div class="chat-layout">
          <button onclick={logout} style="float: right;">ë¡œê·¸ì•„ì›ƒ</button>
        </div>
      {/if}

      <div class="room-input-group" style="padding: 10px;">
        <input bind:value={newRoomTitle} placeholder="ë°© ì œëª© ì…ë ¥..." />
        <button onclick={createRoom}>ìƒì„±</button>
      </div>
      <h3>ğŸ‘¥ ì ‘ì†ì ëª©ë¡</h3>
      <ul>
        {#each users as user}
          <li
            class="user-item"
            onclick={() => inviteUser(user)}
            style="cursor: pointer; padding: 5px;"
          >
            <span class="status-dot {isOnline(user.id) ? 'online' : 'offline'}"
            ></span>
            <span>{user.name || user.id.slice(0, 5)}</span>
          </li>
        {/each}
      </ul>
    </aside>

    <main class="chat-area">
      <nav class="tabs">
        {#each rooms as room}
          <button
            class:active={activeRoomId === room.id}
            onclick={() => (activeRoomId = room.id)}
          >
            {room.title}
          </button>
        {/each}
      </nav>

      <div class="messages">
        {#each messages as msg}
          <div
            class="message {msg.user === pb.authStore.model.id ? 'mine' : ''}"
          >
            <small>{msg.expand?.user?.name || "ìµëª…"}</small>
            <p>{msg.content}</p>
          </div>
        {/each}
      </div>

      <div class="input-box">
        <input
          bind:value={newMessage}
          onkeydown={(e) => e.key === "Enter" && sendMessage()}
          placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
        />
        <button onclick={sendMessage}>ì „ì†¡</button>
      </div>
    </main>
  </div>
<!-- {/if} -->

<style>
  .chat-layout {
    display: flex;
    height: 100vh;
    background: #f0f2f5;
    font-family: sans-serif;
  }
  .user-list {
    width: 220px;
    background: white;
    border-right: 1px solid #ddd;
    padding: 20px;
  }
  .user-item {
    display: flex;
    align-items: center;
    margin-bottom: 12px;
    gap: 10px;
  }

  /* ìƒíƒœ ë¶ˆë¹› ìŠ¤íƒ€ì¼ */
  .status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #bbb;
    transition: all 0.3s;
  }
  .status-dot.online {
    background: #4caf50;
    box-shadow: 0 0 8px #4caf50;
  }

  .chat-area {
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  .tabs {
    display: flex;
    background: #e4e6eb;
  }
  .tabs button {
    padding: 12px 20px;
    border: none;
    cursor: pointer;
    background: none;
  }
  .tabs button.active {
    background: white;
    font-weight: bold;
    border-top: 3px solid #ff6b00;
  }

  .messages {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .message {
    padding: 10px 14px;
    border-radius: 12px;
    background: white;
    max-width: 70%;
    align-self: flex-start;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
  .message.mine {
    align-self: flex-end;
    background: #ffefd5;
  }
  .message small {
    display: block;
    font-size: 0.75rem;
    color: #666;
    margin-bottom: 4px;
  }

  .input-box {
    padding: 20px;
    background: white;
    display: flex;
    gap: 10px;
    border-top: 1px solid #ddd;
  }
  .input-box input {
    flex: 1;
    padding: 12px;
    border: 1px solid #ddd;
    border-radius: 20px;
    outline: none;
  }
  .input-box button {
    padding: 0 20px;
    background: #ff6b00;
    color: white;
    border: none;
    border-radius: 20px;
    cursor: pointer;
  }

  .login-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-width: 300px;
    margin: 100px auto;
    padding: 20px;
    border: 1px solid #ddd;
    border-radius: 8px;
  }
  .login-container input {
    padding: 10px;
  }
  .login-container button {
    padding: 10px;
    background: #ff6b00;
    color: white;
    border: none;
    cursor: pointer;
  }
</style>
